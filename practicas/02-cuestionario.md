### Preguntas de Investigación y Desarrollo (I+D) - C# Avanzado

1.  **Impacto de los Genéricos en la Memoria:** Investiga y explica detalladamente cómo el uso de genéricos resolvió los problemas de rendimiento asociados al *boxing* y *unboxing* de tipos de valor que ocurrían en las colecciones antiguas como `ArrayList`.
2.  **Arquitectura de Varianza:** Desarrolla un escenario donde sea imprescindible el uso de **covarianza (`out`)** y **contravarianza (`in`)**, justificando por qué la invarianza por defecto limitaría la flexibilidad al diseñar interfaces de solo lectura o procesadores de datos.
3.  **Análisis de Restricciones Avanzadas:** Compara las aplicaciones prácticas de la restricción `where T : unmanaged` frente a `where T : struct`, investigando en qué casos de bajo nivel o interoperabilidad es necesaria la primera.
4.  **Evolución del Paradigma Funcional:** Investiga cómo la introducción de las **expresiones lambda** transformó la sintaxis de los métodos anónimos y qué impacto tuvo esto en la creación de código declarativo frente al imperativo.
5.  **Persistencia e Inmutabilidad con Records:** Analiza cómo el uso de **Records** simplifica la implementación de objetos inmutables y de qué manera esta característica facilita el cumplimiento de los principios de la programación funcional.
6.  **Mecánica de los *Closures*:** Investiga cómo el compilador gestiona internamente la captura de variables en las expresiones lambda y explica el riesgo de capturar variables de bucle que cambian su valor antes de la ejecución de la función.
7.  **Optimización de Búsqueda y Big O:** Explica la diferencia de rendimiento entre realizar una búsqueda lineal en una lista desordenada y una búsqueda binaria en un array ordenado, detallando por qué el orden previo es un requisito matemático.
8.  **Diseño de Comparadores Múltiples:** Diseña una estrategia para implementar diferentes criterios de ordenación en una misma clase (por ejemplo, por nombre, por fecha o por relevancia) utilizando `IComparer<T>` de forma independiente al orden natural.
9.  **Estructuras Híbridas de Rendimiento:** Investiga las diferencias de rendimiento y uso de memoria entre `SortedList<K,V>` y `SortedDictionary<K,V>`. Determina en qué escenarios es preferible el acceso por índice que ofrece la versión híbrida.
10. **Globalización y Persistencia de Datos:** Investiga el impacto de `CultureInfo` en el formateo de datos. Explica por qué es una buena práctica utilizar la "Invariant Culture" al guardar datos en archivos o bases de datos frente a la cultura local del usuario.
11. **Estructuras de Datos Especializadas:** Analiza en qué casos específicos de uso de memoria una `LinkedList<T>` podría ser superior a una `List<T>`, considerando el coste de redimensionar el array interno de esta última.
12. **Inmutabilidad y *Structural Sharing*:** Investiga cómo las colecciones inmutables optimizan el uso de memoria al realizar cambios, utilizando el concepto de "compartición estructural" para no duplicar toda la colección en cada operación.
13. **Uso del Builder Pattern en Colecciones:** Explica cómo el uso de un `Builder` en colecciones inmutables optimiza el rendimiento cuando se deben realizar múltiples modificaciones consecutivas antes de obtener la versión final del objeto.
14. **Transparencia Referencial en C#:** Proporciona ejemplos de cómo el estado mutable dentro de un objeto puede romper la transparencia referencial de una función que, a pesar de recibir los mismos argumentos, devuelve resultados distintos.
15. **Localización y Ordenación de Texto:** Investiga cómo `StringComparer` utiliza la información de `CultureInfo` para manejar correctamente la ordenación de caracteres especiales o acentos en diferentes idiomas.
16. **Seguridad en la Exposición de Datos:** Justifica por qué un buen diseño de clases debe exponer sus colecciones internas mediante interfaces de solo lectura como `IReadOnlyList<T>` en lugar de devolver directamente la referencia a la `List<T>` mutable.
17. **Sobrecarga de Operadores y Semántica:** Investiga las reglas de coherencia al sobrecargar operadores de comparación y por qué el lenguaje obliga a implementar también `Equals()` y `GetHashCode()` para mantener la integridad del tipo.
18. **Composición de Funciones de Orden Superior:** Desarrolla el concepto de cómo los **métodos de extensión** genéricos permiten crear "tuberías" (*pipelines*) de datos, transformando la información de forma fluida y legible.
19. **Análisis de Colisiones en el Diccionario:** Investiga qué ocurre con el rendimiento de búsqueda de un `Dictionary<TKey, TValue>` si el método `GetHashCode()` de la clave no está bien distribuido y genera colisiones frecuentes.
Entendido, he sustituido la pregunta sobre los observables por una centrada en la **integridad y consistencia de la comparación de objetos**, un tema fundamental tratado extensamente en las fuentes sobre los contratos de las interfaces `IComparable<T>` e `IEquatable<T>`.
20.  **Integridad en la Comparación de Objetos:** Investiga la importancia de mantener la **consistencia** entre los resultados de los métodos `CompareTo()`, `Equals()` y la sobrecarga de los operadores de comparación. Explica detalladamente qué problemas lógicos y errores en tiempo de ejecución pueden surgir al usar colecciones si, por ejemplo, dos objetos son considerados iguales por `Equals()` pero el método `CompareTo()` devuelve un valor distinto de cero.
